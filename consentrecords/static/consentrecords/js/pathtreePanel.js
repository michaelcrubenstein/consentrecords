/* showPathtree.js */

var PathOverlap = (function() {
	PathOverlap.prototype.r1 = null;
	PathOverlap.prototype.r2 = null;
	PathOverlap.prototype.y = 0.0;
	
	PathOverlap.prototype.intersects = function(other)
	{
		return (Math.min(this.bottom,other.bottom) - Math.max(this.top,other.top)) > 0;
	}
	
	function PathOverlap(i, j)
	{
		this.r1 = i;
		this.r2 = j;
		this.top = Math.max(i.y,j.y);
		this.bottom = Math.max(0, Math.min(i.y + i.height,j.y + j.height));
	}
	
	return PathOverlap;
})();

var PathSpring = (function() {
	PathSpring.prototype.left = null;
	PathSpring.prototype.right = null;
	PathSpring.prototype.e = 0.0;
	
	PathSpring.prototype.flagSpacing = 5;
	PathSpring.prototype.overlapTerm = 16;
	PathSpring.prototype.marginTerm = 4;
	PathSpring.prototype.expandedTerm = 1;	/* For springs that are larger than maxSpacing */
	PathSpring.prototype.maxEnergy = 99999999;
	
	PathSpring.prototype.getEnergy = function()
	{
		var d = this.right.x - (this.left.x + this.left.width);
		if (d < 0)	/* Overlap */
		{
			var minWidth = this.left.width - 12;
			var t = 100 - ((minWidth + d) / minWidth * 100);
			return (t * t * this.overlapTerm) + (this.flagSpacing * this.flagSpacing * this.marginTerm) + this.expandedTerm;
		}
		else if (d < this.flagSpacing)
		{
			d -= this.flagSpacing;
			return d * d * this.marginTerm + this.expandedTerm;	
				/* Add this.expandedTerm so that any amount less than flagSpacing has a greater energy
					than the energy in the first unit greater than flagSpacing */
		}
		else
		{
			return 0;
		}
	}
	
	PathSpring.prototype.setEnergy = function()
	{
		this.e = this.getEnergy();
	}
	
	function PathSpring(left, right)
	{
		this.left = left;
		this.right = right;
	}
	
	return PathSpring;
})();

var FlagData = (function() {
	FlagData.prototype.experience = null;
	FlagData.prototype.x = null;
	FlagData.prototype.y = null;
	FlagData.prototype.height = null;
	FlagData.prototype.width = null;
	FlagData.prototype.springs = null;
	
	FlagData.prototype.flagSpacing = 5;
	FlagData.prototype.maxEnergy = 99999999;
	FlagData.prototype.widthStretchedTerm = 100;
	FlagData.prototype.widthCompressedTerm = 37; /* (5 * 5 - 4 * 4) * PathSpring.marginTerm + 1 */

	FlagData.prototype.getDescription = function()
	{
		var d = this.experience.getValue("Offering");
		if (d && d.getValueID())
			return d.getDescription();
		var s = this.experience.getDatum("User Entered Offering");
		if (s && s.length)
			return s;
		d = this.experience.getValue("Service");
		if (d && d.getValueID())
			return d.getDescription();
		s = this.experience.getDatum("User Entered Service");
		if (s && s.length)
			return s;
		return "None";
	}
	
	FlagData.prototype.pickedOrCreatedValue = function(pickedName, createdName)
	{
		return getPickedOrCreatedValue(this.experience, pickedName, createdName);
	}
	
	/* Returns the sum of the energies of left energies of this set of left springs */
	FlagData.prototype._getLeftEnergy = function(springs, f)
	{
		var _this = this;
		var fds = springs.map(function(s) { return s.left; });
		var energies = fds.map(function(fi) { return f(fi.rightSprings()); });
		return energies.reduce(function(a, b) { return a + b; }, 0.0);
	}
	
	/* Returns the sum of the energies of left energies of this set of right springs */
	FlagData.prototype._getRightEnergy = function(springs, f)
	{
		var _this = this;
		var fds = springs.map(function(s) { return s.right; });
		var energies = fds.map(function(fi) { return f(fi.leftSprings()); });
		return energies.reduce(function(a, b) { return a + b; }, 0.0);
	}
	
	/* Returns the energy that attracts this object to its walls or screen edges. */
	FlagData.prototype.getXSpringEnergy = function(f)
	{
		var rightSprings = this.rightSprings();
		var leftSprings = this.leftSprings();
		
		var leftEnergy = f(leftSprings) + this._getLeftEnergy(leftSprings, f);
		var rightEnergy = f(rightSprings) + this._getRightEnergy(rightSprings, f);
			
		return leftEnergy + rightEnergy;
	}
	
	FlagData.prototype._getMaxCachedSpringEnergy = function(springs)
	{
		var energies = springs.map(function(s) { return s.e; });
		return energies.reduce(function(a, b) { return Math.max(a, b); }, 0.0);
	}
	
	FlagData.prototype._getMaxSpringEnergy = function(springs)
	{
		var energies = springs.map(function(s) { return s.getEnergy(); });
		return energies.reduce(function(a, b) { return Math.max(a, b); }, 0.0);
	}
	
	/* Returns the energy that attracts this object to its walls or screen edges. */
	FlagData.prototype.getCachedSpringEnergy = function()
	{
		return this.getXSpringEnergy(this._getMaxCachedSpringEnergy);
	}
	
	/* Returns the energy that attracts this object to its walls or screen edges. */
	FlagData.prototype.getCurrentSpringEnergy = function()
	{
		return this.getXSpringEnergy(this._getMaxSpringEnergy);
	}
	
	/* Returns the energy that is generated by compressing the width of this item such that its text doesn't all appear. */
	FlagData.prototype.getWidthEnergy = function()
	{
		var d = this.width - this.bestWidth;
		if (d > 0)
			return (d * d * this.widthStretchedTerm);
		else
		{
			/* Normalize the range from 0 to 100 */
			d = d / this.bestWidth * 100;
			return d * d * this.widthCompressedTerm;
		}
	}
	
	/* Returns massive amounts of energy if this item falls outside the display area. */
	FlagData.prototype.getXBoundEnergy = function(maxX)
	{
		if (this.x < 0)
			return this.maxEnergy;
		else if (this.x + this.width > maxX)
		{
			var d = maxX - (this.x + this.width);
			var t = d / this.width * 100;	/* Normalize to a range from 0 to 100. */
			return t * t * PathSpring.prototype.overlapTerm * 4 + (this.flagSpacing * this.flagSpacing * PathSpring.prototype.marginTerm);
		}
		else if (this.x + this.width > maxX - this.flagSpacing)
		{
			var d = maxX - this.flagSpacing - (this.x + this.width);
			return d * d * PathSpring.prototype.marginTerm;
		}
		else
			return 0;
	}
	
	FlagData.prototype.cacheFlagEnergy = function(rightEdge)
	{
		this.flagEnergy = this.getWidthEnergy() + this.getXBoundEnergy(rightEdge);
	}
	
	FlagData.prototype.setEnergy = function(rightEdge)
	{
		this.springs.forEach(function(s) { s.setEnergy(); });
		this.cacheFlagEnergy(rightEdge);
	}
	
	FlagData.prototype.getCachedEnergy = function()
	{
		return this.getCachedSpringEnergy() + this.flagEnergy;
	}
	
	FlagData.prototype.getCurrentEnergy = function(rightEdge)
	{
		return this.getWidthEnergy() + this.getXBoundEnergy(rightEdge) +
			this.getCurrentSpringEnergy();
	}
	
	FlagData.prototype.incrementX = function(dx)
	{
		this.x += dx;
	}
	
	FlagData.prototype.incrementWidth = function(dx)
	{
		this.width += dx;
	}
	
	FlagData.prototype.incrementLeft = function(dx)
	{
		/* Keep the right edge the same, but move the left edge. */
		this.x += dx;
		this.width -= dx;
	}
	
	/* Get the change in energy of fi when the value of the specified field changes by dx. */
	FlagData.prototype.getDelta = function(f, dx, rightEdge)
	{
		f.call(this, dx);
		
		var delta = this.getCurrentEnergy(rightEdge) - this.getCachedEnergy();
		
		f.call(this, -dx);
		
		return delta;
	}
	
	FlagData.prototype.rightSprings = function()
	{
		var _this = this;
		return this.springs.filter(function(s) { return s.left == _this; });
	}
	
	FlagData.prototype.leftSprings = function()
	{
		var _this = this;
		return this.springs.filter(function(s) { return s.right == _this; });
	}
	
	FlagData.prototype.setSpanWidth = function(rightEdge)
	{
		var maxRightSpan = this.rightSprings()
			.map(function(s) {
				if (s.right.isFixed)
					return rightEdge - s.right.x;
				else
					return s.right.spanWidth;
				})
			.reduce(function(a, b) { return Math.max(a, b); }, 0.0);
		this.spanWidth = this.width + (maxRightSpan === 0.0 ? 0.0 : maxRightSpan + this.flagSpacing);
	}
	
	FlagData.prototype.getService = function()
	{
		var offering = this.experience.getValue("Offering");
		if (offering && offering.getValueID())
		{
			var service = offering.getValue("Service");
			if (service)
				return service;
		}
		return this.experience.getValue("Service");
	}
	
	FlagData.prototype.getServiceDomain = function()
	{
		var service = this.getService();
		if (!service || !service.getValueID())
			return null;
		service = crp.getInstance(service.getValueID());
		var domain = service.getValue("Domain");
		if (domain)
			var sd = crp.getInstance(domain.getValueID()).getValue("Service Domain");
			if (sd)
				return sd;
		return service.getValue("Service Domain");
	}

	FlagData.prototype.getStage = function()
	{
		var service = this.getService();
		return service && service.getValueID() && crp.getInstance(service.getValueID()).getValue("Stage")
	}

	FlagData.prototype.getColumn = function()
	{
		var sd = this.getServiceDomain();
		if (sd && sd.getDescription() == "Housing")
			return 0;
		var stage = this.getStage();
		var stageDescription = stage && stage.getDescription();
		if (stageDescription)
		{
		if (["Studying", "Training", "Certificate"].indexOf(stageDescription) >= 0)
			return 1;
		if (["Working", "Teaching", "Expert"].indexOf(stageDescription) >= 0)
			return 2;
		if (["Mentoring", "Tutoring", "Coaching", "Volunteering"].indexOf(stageDescription) >= 0)
			return 3;
		}
		if (sd && sd.getDescription() == "Wellness")
			return 4;
		/* Whatever/ Other */
		return 5;
	}
	
	FlagData.prototype.getStartDate = function()
	{
		return this.experience.getDatum("Start");
	}
	
	FlagData.prototype.getEndDate = function()
	{
		return this.experience.getDatum("End") || new Date().toISOString().substr(0, 10);
	}
	
	FlagData.prototype.getColor = function()
	{
		var color = null;
		var stage = this.getStage();
		if (stage && stage.getValueID())
		{
			color = crp.getInstance(stage.getValueID()).getValue("Color");
			if (color && color.text)
				return color.text;
		}
		
		sd = this.getServiceDomain();
		if (sd && sd.getValueID())
		{
			color = crp.getInstance(sd.getValueID()).getValue("Color");
			if (color && color.text)
				return color.text;
		}
		
		return null;
	}
	
	function FlagData(experience)
	{
		this.experience = experience;
		this.y = null;
		this.x = null;
		this.height = null;
		this.width = null;
	}
	return FlagData;
})();

var Pathtree = (function () {
	Pathtree.prototype.dataTopMargin = 5;
	Pathtree.prototype.dataBottomMargin = 5;
	Pathtree.prototype.dataLeftMargin = 40;			/* The space between the left margin and the beginning of the flags */
	Pathtree.prototype.textLeftMargin = 3;
	Pathtree.prototype.textRightMargin = 3;
	Pathtree.prototype.textBottomBorder = 3;
	Pathtree.prototype.flagsLeftMargin = 14;
	Pathtree.prototype.flagsRightMargin = 14;
	Pathtree.prototype.flagSpacing = 5;
	Pathtree.prototype.stemHeight = 3;
	Pathtree.prototype.otherColor = "#bbbbbb";
	Pathtree.prototype.textDetailLeftMargin = 7; /* textLeftMargin; */
	Pathtree.prototype.textDetailRightMargin = 7; /* textRightMargin; */
	Pathtree.prototype.detailTextSpacing = "1.1em";		/* The space between lines of text in the detail box. */
	Pathtree.prototype.pathBackground = "white";
	Pathtree.prototype.showDetailIconWidth = 18;
	
	Pathtree.prototype.user = null;
	Pathtree.prototype.allExperiences = [];
	Pathtree.prototype.sitePanel = null;
	Pathtree.prototype.containerDiv = null;
	Pathtree.prototype.pathwayContainer = null;
	Pathtree.prototype.timeContainer = null;
	Pathtree.prototype.svg = null;
	Pathtree.prototype.svgTime = null;
	Pathtree.prototype.loadingMessage = null;
	Pathtree.prototype.defs = null;
	Pathtree.prototype.bg = null;
	Pathtree.prototype.bgTime = null;
	Pathtree.prototype.loadingText = null;
	Pathtree.prototype.promptAddText = null;
	Pathtree.prototype.experienceGroup = null;
	Pathtree.prototype.yearGroup = null;
	Pathtree.prototype.detailGroup = null;
	Pathtree.prototype.detailBackRect = null;
	Pathtree.prototype.detailFrontRect = null;
	
	Pathtree.prototype.detailFlagData = null;
	Pathtree.prototype.flagElement = null;
	Pathtree.prototype.flagHeight = 0;
	Pathtree.prototype.flagWidth = 0;
	
	Pathtree.prototype.minDate = null;
	Pathtree.prototype.maxDate = null;
	Pathtree.prototype.timespan = 0;
	Pathtree.prototype.isLayoutDirty = true;
	Pathtree.prototype.isMinHeight = false;
	Pathtree.prototype.dayHeight = 0;
	Pathtree.prototype.years = [];
	
	Pathtree.prototype.nextClipID = 1;
	Pathtree.prototype.clipID = null;
	
	//This is the accessor function we talked about above
	Pathtree.prototype._lineFunction = d3.svg.line()
		.x(function(d) { return d.x; })
		.y(function(d) { return d.y; })
		.interpolate("linear");

	Pathtree.prototype._compareExperiences = function(a, b)
	{
		var aOrder = a.column;
		var bOrder = b.column;
		if (aOrder != bOrder)
			return aOrder - bOrder;
		
		var aStartDate = a.getStartDate();
		var bStartDate = b.getStartDate();
		if (aStartDate > bStartDate) return 1;
		else if (aStartDate < bStartDate) return -1;
		else
		{
			var aEndDate = a.getEndDate();
			var bEndDate = b.getEndDate();
			if (aEndDate > bEndDate) return 1;
			else if (aEndDate < bEndDate) return -1;
			else return 0;
		}
		return aStartDate - bStartDate;
	}

	Pathtree.prototype.DateToY = function(d)
	{
		var daySpan = (new TimeSpan(d-this.minDate)).days;
		return this.dataTopMargin + (this.timespan - daySpan) * this.dayHeight;
	}

	Pathtree.prototype.getExperienceY = function(fd)
	{
		return this.DateToY(Date.parse(getEndDate(fd.experience)));
	}

	Pathtree.prototype.getExperienceHeight = function(fd)
	{
		var startDate = fd.getStartDate();
		var endDate = fd.getEndDate();
		var days = (new TimeSpan(Date.parse(endDate)-Date.parse(startDate))).days;
		return days * this.dayHeight;
	}

	Pathtree.prototype.getExperiencePath = function(g, fd)
	{
		var h = fd.height;
		var x1 = 0;
		var x2 = x1 + fd.width;
		var y1 = 0;
		var y4 = y1 + h;
		return this._lineFunction([{x: x1, y: y1}, 
							 {x: x2, y: y1}, 
							 {x: x2, y: y4}, 
							 {x: x1, y: y4}, 
							 {x: x1, y: y1}]);
	}
	
	Pathtree.prototype.clearLayout = function()
	{
		/* Do whatever it takes to force layout when checkLayout is called. */
		this.isLayoutDirty = true;
	}
	
	Pathtree.prototype.truncatedText = function(text, textNode, maxWidth)
	{
		var t = d3.select(textNode);
		t.text(text);
		if (text.length <= 1)
			return;
		else if (textNode.getBBox().width <= maxWidth)
			return;
		
		var testText = text.slice(0, -1);
		while (testText.length > 0)
		{
			t.text(testText + "...");
			if (textNode.getBBox().width <= maxWidth)
				return;
			testText = testText.slice(0, -1);
		}
		t.text("...");
	}
	
	Pathtree.prototype.scaleDayHeightToSize = function()
	{
		var containerHeight = $(this.svg.node()).height();
		var dataHeight = containerHeight - this.dataTopMargin - this.dataBottomMargin;
		var oldDayHeight = this.dayHeight;
		this.dayHeight = dataHeight / this.timespan;
		return oldDayHeight != this.dayHeight;
	}
	
	Pathtree.prototype.bestDeltaF = function(f, delta)
	{
		return function(previous, current, index)
		{
			if (current < previous.e)
				return {e: current, delta: delta, index: index, f: f};
			else
				return previous;
		}
	}
	
	Pathtree.prototype.iterate = function(fds, delta, rightEdge)
	{
		var best = {e: 0.0, delta: 0.0, index: -1};
		
		var _this = this;
		[FlagData.prototype.incrementX,
		 FlagData.prototype.incrementWidth,
		 FlagData.prototype.incrementLeft].forEach(function(f)
			{
				best = fds.map(function(fi) { return fi.getDelta(f, delta, rightEdge); })
					.reduce(_this.bestDeltaF(f, delta), best);
				best = fds.map(function(fi) { return fi.getDelta(f, -delta, rightEdge); })
					.reduce(_this.bestDeltaF(f, -delta), best);
			});
			
		if (best.e < -0.01)
		{
			var fi = fds[best.index];
			best.f.call(fi, best.delta);
			fi.setEnergy(rightEdge);
			
			return best;
		}
		else
			return false;
	}
	
	Pathtree.prototype.drawExperiences = function(g)
	{
		var _this = this;
		g.attr("transform", 
			function(fd)
			{
				return "translate(" + fd.x + "," + fd.y + ")";
			})
			
		if (g.size() > 0)
		{
			/* Transform each text node relative to its containing group. */
			g.selectAll('text')
				.each(function(fd) { _this.truncatedText(fd.getDescription(), this, 
						Math.max(fd.width - _this.textLeftMargin - _this.textRightMargin, 0)); });
			
			/* Calculate the path for each containing group. */
			g.selectAll('rect')
				.attr("width", function(fd) { return fd.width; } )
				.attr("height", function(fd) { return fd.height; });
			g.selectAll('line')
				.attr('y2', function(fd) { return fd.height; });
		}

		/* Hide the detail so that if detail is visible before a resize, it isn't left behind. */	
		if (this.detailFlagData != null)
		{
			this.refreshDetail();
		}
	}
	
	Pathtree.prototype.drawSprings = function(lines)
	{
		var _this = this;
		lines.attr('x1', function(d) { return d.left.x + d.left.width; })
			.attr('y1', function(d) { return d.left.y + d.left.height / 2; })
			.attr('x2', function(d) { return d.right.x; })
			.attr('y2', function(d) { return d.right.y + d.right.height / 2; })
			.attr('stroke-width', 2)
			.attr('stroke', '#222222');
	}
	
	Pathtree.prototype.getSprings = function(fds)
	{
		fds.forEach(function(fd, index) { fd.springs = []; fd.overlaps = []; fd.index = index;});

		fds.sort(function(a, b) {
			if (a.y != b.y)
				return a.y - b.y;
			if (a.height != b.height)
				return b.height - a.height;
			if (a.column != b.column)
				return b.column - a.column;
			return b.index - a.index;
			});
			
		/* Create a spring between each pair of items whose y values overlap, but there isn't an item
			that overlaps both of them with an x value between them.
		 */
		
		/* First, create the overlaps for each experience. 
			For each experience (fi), an overlap is created for experiences that are after it and 
			whose y coordinate is less than this item plus its height. The overlap is associated with
			the experience (fi or fj) that has the minimum x-coordinate.
		 */
		fds.forEach(function(fi, index)
			{
				var maxY = fi.y + fi.height;
				for (var j = index + 1; j < fds.length && fds[j].y < maxY; ++j)
				{
					var fj = fds[j];
					if (fj.x > fi.x)
					{
						fi.overlaps.push(new PathOverlap(fi, fj));
					}
					else
					{
						fj.overlaps.push(new PathOverlap(fj, fi));
					}
				}
			});
		
		/* Sort the overlaps by their x coordinate, filter for only overlaps that
			don't intersect with other overlaps and create springs for each such overlap.
			
			return the total list of springs.
		 */
		return fds.map(function(fi)
			{
				var s = fi.overlaps
					.sort(function(a, b) { return a.r2.x - b.r2.x; })
					.filter(function(overlapJ, jIndex)
						{
							for (var k = 0; k < jIndex; ++k)
							{
								if (overlapJ.intersects(fi.overlaps[k]))
									return false;
							}
							return true;
						})
					.map(function(overlapJ) { return new PathSpring(fi, overlapJ.r2); });
					
				/* Add each spring to its left and right edge. */
				s.forEach(function (spring) {
					spring.left.springs.push(spring);
					spring.right.springs.push(spring);
				});
				return s;
			})
			.reduce(function(a, b) { return a.concat(b); }, []);
	}
	
	Pathtree.prototype.setSprings = function(fds)
	{
		var springs = this.getSprings(fds);
		springs.forEach(function(s) { s.setEnergy(); });
		return springs;
	}
	
	Pathtree.prototype.draw = function(g)
	{
		this.drawExperiences(g);
	}
	
	/* Optimize the positions of the flags so that they overlap as little as possible
		and as much of their text is visible.
		
		This method uses an iterative minimization that finds the highest energy change
		from changing the x or width values of an item and iterates with smaller and
		smaller increments (32 down to 1) until there isn't a substantive change.
		
		Brute force, but fast enough, so far.
	 */
	Pathtree.prototype.optimize = function(g)
	{
		var fds = g.data();
		if (fds.length == 0)
			return;
			
		var springs = this.setSprings(fds);
				
		var _this = this;
		var rightEdge = $(this.svg.node()).width();
		
		/* Step 1: lay out the items based on their springs without compression anything. */
		var items = fds.slice();
		
		/* Clear spanWidth (because it is used in the test below) and isFixed (because it is
			used internally in setSpanWidth).
		 */
		fds.forEach(function(fi) { fi.spanWidth = 0.0; fi.isFixed = false;});
		while (items.length > 0)
		{
			/* For every item in the list that has no lines to the right that are in the list, 
				add its width + flagSpacing to all of its items on the left 
				and remove it from the list. */
			items.filter(function(fi)
					{
						return fi.springs.filter(function(s) { return s.left == fi && 
																	  s.right.spanWidth == 0.0; }).length == 0; 
					})
				.forEach(function(fi)
					{
						fi.setSpanWidth(rightEdge);
						items.splice(items.indexOf(fi), 1);
					});
		}
		items = fds.slice();
		items.sort(function(a, b) { return b.spanWidth - a.spanWidth; });
		rightEdge = items[0].spanWidth;
		
		var stack;
		function pushNeighbors(fi)
		{
			/* Don't push items on the right if there are items on its left which are not yet set. */
			fi.rightSprings().filter(function(s) { return !s.right.isFixed &&
				s.right.leftSprings().find(function(s) { return !s.left.isFixed; }) === undefined; })
				.sort(function(a, b) { return a.right.spanWidth - b.right.spanWidth; })
				.forEach(function(s) { stack.push(s.right); });
			fi.leftSprings().filter(function(s) { return !s.left.isFixed; })
				.sort(function(a, b) { return a.left.width - b.left.width; })
				.forEach(function(s) { stack.push(s.left); });
		}
		function placeFlag(fi, x)
		{
			fi.x = x;
			fi.isFixed = true;
			items.splice(items.indexOf(fi), 1);
			pushNeighbors(fi);
		}
		
		/* Now place all of the items */
		while (items.length > 0)
		{
			/* Find the item with the largest spanWidth. */
			var fi = items.shift();
			
			fi.x = 0.0;
			fi.isFixed = true;
			
			/* Place items that aren't already placed relative to this item. */
			stack = [];
			pushNeighbors(fi);
			while (stack.length > 0)
			{
				fi = stack.pop();
				if (!fi.isFixed)
				{
					var maxRight = fi.leftSprings().filter(function(s) { return s.left.isFixed; })
						.map(function(s) { return s.left.x + s.left.width; })
						.reduce(function(a, b) { return Math.max(a, b) }, -Infinity);
					if (maxRight > -Infinity)
						placeFlag(fi, maxRight + fi.flagSpacing);
					else
					{
						var minX = fi.rightSprings().filter(function(s) { return s.right.isFixed; })
							.map(function(s) { return s.right.x; })
							.reduce(function(a, b) { return Math.min(a, b) }, Infinity);
						if (minX < Infinity)
							placeFlag(fi, minX - fi.flagSpacing - fi.width);
						else
							throw "Invalid case: can not position flag";
					}
				}
			}
		}
		
		/* Step 2: Use a new set of springs and other energy terms to compress the flags within the specified width. */
		rightEdge = $(this.svg.node()).width();
		springs = this.setSprings(fds);
		fds.forEach(function(fi) { 
			fi.cacheFlagEnergy(rightEdge);
		});
		
		var delta = 32;
		while (delta >= 1)
		{
			while (this.iterate(fds, delta, rightEdge))
			{
				continue;
			}
			delta /= 2;
		}
		
		/* Step 3: Recompute the springs to ensure that newly separated items don't overlap. */
		springs = this.setSprings(fds);
				
		/* Set the spanWidth of every item leftover to the width of the span from it to the right */
		fds.forEach(function(fi) { fi.isFixed = (fi.width < fi.bestWidth); });
		items = fds.filter(function(fi) { return !fi.isFixed; });
		fds.forEach(function(fi) { fi.spanWidth = 0.0; });
		
		/* For any item to the right of a compressed item, don't shift those items. */
		var cQueue = items.filter(function(fi)
			{
				return fi.leftSprings().filter(function(s) { return s.left.isFixed; }).length > 0;
			});
		while (cQueue.length > 0)
		{
			var fi = cQueue.shift();
			fi.isFixed = true;
			var index = items.indexOf(fi);
			if (index >= 0)
			{
				items.splice(index, 1);
				fi.rightSprings().forEach(function(s)
					{
						cQueue.push(s.right);
					});
			}
		}
		
		while (items.length > 0)
		{
			/* For every item in the list that has no lines to the right that are in the list, 
				add its width + flagSpacing to all of its items on the left 
				and remove it from the list. */
			items.filter(function(fi)
					{
						return fi.springs.filter(function(s) { return s.left == fi && 
																	  s.right.spanWidth == 0.0 &&
																	  !s.right.isFixed; }).length == 0; 
					})
				.forEach(function(fi)
					{
						fi.setSpanWidth(rightEdge);
						items.splice(items.indexOf(fi), 1);
					});
		}
		
		/* Make a list of every item */
		items = fds.filter(function(fi) { return !fi.isFixed; });
		items.sort(function(a, b) { return b.spanWidth - a.spanWidth; });
		
		/* If all of the items are variable length, then limit the right edge to the
			maximum width (forcing all items left).
		 */
		if (items.length == fds.length && items.length > 0)
			rightEdge = items[0].spanWidth;
		
		/* Now place all of the items */
		while (items.length > 0)
		{
			/* Find the item with the largest spanWidth. */
			var fi = items.shift();
			
			/* If it is to the right of a fixed item, then place it there, otherwise
				place it so that its maxSpan is centered from 0 to rightEdge. */
			var maxLeft = fi.leftSprings()
				.map(function(s) {
					if (s.left.isFixed)
						return s.left.x + s.left.width;
					else
						return 0.0;
					})
				.reduce(function(a, b) { return Math.max(a, b); }, 0.0);
			fi.x = maxLeft > 0.0 ? maxLeft + fi.flagSpacing : 0.0;
			fi.isFixed = true;
			
			/* Place items that aren't already placed relative to this item. */
			stack = [];
			pushNeighbors(fi);
			while (stack.length > 0)
			{
				fi = stack.pop();
				if (!fi.isFixed)
				{
					var maxRight = fi.leftSprings().filter(function(s) { return s.left.isFixed; })
						.map(function(s) { return s.left.x + s.left.width; })
						.reduce(function(a, b) { return Math.max(a, b) }, -Infinity);
					if (maxRight > -Infinity)
						placeFlag(fi, maxRight + fi.flagSpacing);
					else
					{
						var minX = fi.rightSprings().filter(function(s) { return s.right.isFixed; })
							.map(function(s) { return s.right.x; })
							.reduce(function(a, b) { return Math.min(a, b) }, Infinity);
						if (minX < Infinity)
							placeFlag(fi, minX - fi.flagSpacing - fi.width);
						else
							throw "Invalid case: can not position flag";
					}
				}
			}
		}
		
		this.draw(g);
	}
	
	/* Lay out all of the contents within the svg object. */
	Pathtree.prototype.layout = function()
	{
		var svgHeight = $(this.svg.node()).height();
		
		this.isMinHeight = (svgHeight == $(this.containerDiv).height());
		$(this.bg.node()).height(svgHeight);
		$(this.bg.node()).width($(this.svg.node()).width());
		$(this.bgTime.node()).height(svgHeight);
		
		this.sitePanel.contractButton
			.classed('disabled', svgHeight <= $(this.containerDiv).height())
			.classed('enabled', svgHeight > $(this.containerDiv).height());
	
		var g = this.experienceGroup.selectAll('g');
		var y = this.yearGroup.selectAll('text');
		
		var _thisPathway = this;
		
		g.each(function(fd)
		{
			fd.column = fd.getColumn();
		});
		numColumns = g.data().map(function(fd) { return fd.column; })
							 .reduce(function(a, b) { if (a > b) return a; else return b; }, -1) + 1;
		
		/* Restore the sort order to startDate/endDate */
		g.sort(function(a, b)
		{
			return _thisPathway._compareExperiences(a, b);
		});
	
		var columns = new Array(numColumns);
		for (i = 0; i < numColumns; ++i)
			columns[i] = [];

		/* Reset the text for each object, in case it was previously squashed. */
		g.selectAll('text').text(function(d) { return d.getDescription(); });
		
		/* Fit each item to a column, according to the best layout. */	
		g.each(function(fd, i)
			{
				fd.y = _thisPathway.getExperienceY(fd);
				fd.height = _thisPathway.getExperienceHeight(fd);
				var textNode = d3.select(this).selectAll('text').node();
				if (fd.height < _thisPathway.flagHeight)
				{
					$(textNode).css('font-size', '10px');
					if (fd.height < _thisPathway.smallFlagHeight)
						fd.height = _thisPathway.smallFlagHeight;
					$(textNode).attr('y', 0 - _thisPathway.smallFlagY);
				}
				else
				{
					$(textNode).css('font-size', '');
					$(textNode).attr('y', 0 - _thisPathway.flagY);
				}
				
				fd.width = textNode.getBBox().width + 
							_thisPathway.textLeftMargin + _thisPathway.textRightMargin;
				fd.bestWidth = fd.width;
				fd.bestY = fd.y;
				columns[fd.column].push(this);
			});
		
		/* Compute the column width for each column of flags + spacing to its right. 
			Add flagSpacing before dividing so that the rightmost column doesn't need spacing to its right.
		 */
	
		var flagColumnWidth = ($(this.svg.node()).width() - this.flagsRightMargin + this.flagSpacing) / columns.length;
		this.flagWidth = flagColumnWidth - this.flagSpacing;
		
		/* Compute the x attribute for every item */
		/* Then, Add the items to the flag columns in the column order for better results than
			the current sort order.
		 */
		for (var j = 0; j < columns.length; ++j)
		{
			var x = (flagColumnWidth * j);
			var column = columns[j];
			var tops = new Array(column.length);
			for (var i = 0; i < column.length; ++i)
			{
				var fd = d3.select(column[i]).datum();
				for (var k = 0; k <= i; ++k)
				{
					if (!tops[k] || tops[k].y >= fd.y + fd.height)
					{
						tops[k] = fd;
						fd.x = x + (k * 2);
						break;
					}
				}
				
				fd.column = j;
			}
		}
		
		if (this.detailFlagData != null)
		{
			/*( Restore the flagElement */
			 g.each(function(fd)
			 {
				if (fd === _thisPathway.detailFlagData)
					_thisPathway.flagElement = this;
			 });
		}
		
		y.attr("y", function(d) { 
				return _thisPathway.DateToY(new Date(d, 0, 0));
			});
			
		if (y.size() >= 2)
		{
			var oldD0 = y[0][0];
			var thisHeight = oldD0.getBBox().height;
			var spacing = 365 * this.dayHeight;
			
			var yearPeriod = parseInt(thisHeight / spacing) + 1;
			if (yearPeriod == 1)
				y.attr("display", null);
			else
			{
				// Set the target so that the latest year is always visible.
				var target = (y.size() - 1) % yearPeriod;
				y.attr("display", function(d, i) { if (i % yearPeriod == target) return null; else return "none";});
			}
		}
		
		this.defs.selectAll('clipPath').remove();
		
		/* Add a clipPath for the text box size. */
		this.defs.append('clipPath')
			.attr('id', 'id_detailClipPath{0}'.format(this.clipID))
			.append('rect');
		this.defs.append('clipPath')
			.attr('id', 'id_detailIconClipPath{0}'.format(this.clipID))
			.append('rect');

		/* Here optimize the positions of all of the fd's. */
		/*
			t1 is the area of overlap between two rectangles.
			t2 is the area of an object outside the bounds of the display area.
			t3 is the square of the distance from a fixed edge.
			t4 is the square of the cut-off of the text.
			t5 is the square of the distance of the time middle from the rectangle's middle.
			
			v1 = x
			v2 = y
			v3 = width
		 */
	
		this.optimize(g);
	}

	Pathtree.prototype.checkLayout = function()
	{
		if ($(this.containerDiv).width() === 0)
			return;
		
		if (!this.isLayoutDirty)
			return;
		
		/* Calculate the height of the area where data appears and the height of a single day. */
		var dataHeight = this.dayHeight * this.timespan;
		var svgHeight = dataHeight + this.dataTopMargin + this.dataBottomMargin;
		var containerHeight = $(this.containerDiv).height();
		var containerWidth = $(this.containerDiv).width();

		$(this.svg.node()).height(svgHeight);
		$(this.svgTime.node()).height(svgHeight);
		
		this.layout();
		this.isLayoutDirty = false;
	}
	
	Pathtree.prototype.scale = function(multiple, done)
	{
		var newDataHeight = this.dayHeight * multiple * this.timespan;
		var newContainerHeight = Math.max(newDataHeight + this.dataTopMargin + this.dataBottomMargin, 
										  $(this.containerDiv).height());
										  
		var _this = this;
		$(this.svg.node()).animate({height: newContainerHeight},
		   {duration: 400, easing: "swing",
			progress: function(animation, progress, remainingMs)
				{
					var containerNode = _this.pathwayContainer.node();
					var newContainerHeight = $(_this.svg.node()).height();
					var newContainerWidth = Math.max($(containerNode).width(),
													 newContainerHeight * $(_this.containerDiv).width() / $(_this.containerDiv).height()
														- _this.dataLeftMargin);
					var oldCenter = containerNode.scrollTop + $(containerNode).height() / 2;
					var oldDayHeight = _this.dayHeight;
					$(_this.svg.node()).width(newContainerWidth);
					$(_this.svgTime.node()).height(newContainerHeight);
					if (_this.scaleDayHeightToSize())
					{
						_this.layout();
						var newCenter = (oldCenter - _this.dataTopMargin) * (_this.dayHeight / oldDayHeight) + _this.dataTopMargin;
						if (containerNode.scrollTop > 0)
						{
							containerNode.scrollTop += newCenter - oldCenter;
							_this.timeContainer.node().scrollTop = containerNode.scrollTop;
						}
					}
				},
			 complete: done
			});
	}
	
	Pathtree.prototype.setDateRange = function()
	{
		this.maxDate = new Date().toISOString().substr(0, 10);

		var birthday = this.user.getValue("Birthday");
		if (birthday && birthday.text)
			this.minDate = birthday.text;
		else
			this.minDate = this.maxDate;
		
		var _this = this;
		this.minDate = this.allExperiences.map(function(e)
			{
				return getStartDate(e);
			}).reduce(function(a, b) { if (a < b) return a; else return b; }, this.minDate);
		this.minDate = new Date(this.minDate);
		
		this.maxDate = this.allExperiences.map(function(e)
			{
				return getEndDate(e);
			}).reduce(function(a, b) { if (a > b) return a; else return b; }, this.maxDate);
		this.maxDate = new Date(this.maxDate);
					
		/* Make the timespan start on Jan. 1 of that year. */
		this.minDate.setUTCMonth(0);
		this.minDate.setUTCDate(1);
		
		if (this.maxDate < this.minDate)
		{
			/* Make sure that the maxDate is at least 365 days after the minDate, but no later than today. */
			this.maxDate = (new Date(this.minDate)).addDays(365);
			if (this.maxDate > new Date())
				this.maxDate = new Date();
		}
		
		/* Now make sure that the minimum date is at least a year before the maximum date. */
		var maxMinDate = (new Date(this.maxDate)).addDays(-365);
		if (this.minDate > maxMinDate)
			this.minDate = maxMinDate;
	
		this.timespan = new TimeSpan(this.maxDate - this.minDate).days;

		var minYear = this.minDate.getUTCFullYear();
		var maxYear = this.maxDate.getUTCFullYear();
		this.years = [];
		for (var y = minYear; y <= maxYear; ++y)
			this.years.push(y);

		/* create the set of text objects for each year. */
		this.yearGroup.selectAll('text').remove();
		this.yearGroup
			.selectAll('text')
			.data(this.years)
			.enter()
			.append('text')
			.text(function(d) { return d; })
			.attr("font", "sans-serif")
			.attr("font-size", "10px")
			.attr("x", this.textLeftMargin);
;
	}
	
	Pathtree.prototype.checkDateRange = function(experience)
	{
		var oldMinDate = this.minDate;
		var oldMaxDate = this.maxDate;
		var oldMinYear = this.minDate.getUTCFullYear();	
		var oldMaxYear = this.maxDate.getUTCFullYear();	
		
		var startDate = new Date(getStartDate(experience));
		var endDate = new Date(getEndDate(experience));
		if (this.minDate > startDate)
			this.minDate = startDate;
		if (this.maxDate < endDate)
			this.maxDate = endDate;
		
		/* Make the timespan start on Jan. 1 of that year. */
		this.minDate.setUTCMonth(0);
		this.minDate.setUTCDate(1);
		
		var minYear = this.minDate.getUTCFullYear();
		var maxYear = this.maxDate.getUTCFullYear();
		
		this.timespan = new TimeSpan(this.maxDate - this.minDate).days;
		if (minYear < oldMinYear || maxYear > oldMaxYear)
		{
			this.years = [];
			for (var y = minYear; y <= maxYear; ++y)
				this.years.push(y);

			/* create the set of text objects for each year. */
			this.yearGroup.selectAll('text').remove();
			this.yearGroup
				.selectAll('text')
				.data(this.years)
				.enter()
				.append('text')
				.text(function(d) { return d; })
				.attr("font", "sans-serif")
				.attr("font-size", "10px")
				.attr("x", this.textLeftMargin);
		}
			
		return this.minDate < oldMinDate || this.maxDate > oldMaxDate;
	}
	
	Pathtree.prototype.setColor = function(r, fd)
	{
		var colorText = fd.getColor() || this.otherColor;
		d3.select(r).attr("fill", colorText)
			 		.attr("stroke", colorText);
	}

	Pathtree.prototype.showDetailPanel = function(fd, i)
	{
		if (fd.experience.typeName == "Experience") {
			;	/* Nothing to edit */
		}
		else
		{
			if (prepareClick('click', 'show experience detail: ' + fd.getDescription()))
			{
				var panel = $(this).parents(".site-panel")[0];
				var editPanel = new EditExperiencePanel(fd.experience, panel, revealPanelLeft);
												  
				revealPanelLeft(editPanel.node());
				d3.event.stopPropagation();
			}
		}
	}
	
	Pathtree.prototype.showDetailGroup = function(g, fd, duration)
	{
		duration = (duration !== undefined ? duration : 700);
		var _this = this;
		
		this.detailGroup.datum(fd);
		this.detailGroup.selectAll('rect').datum(fd);
		var detailText = this.detailGroup.append('text')
			.attr("width", "100")
			.attr("height", "1")
			.attr('clip-path', 'url(#id_detailClipPath{0})'.format(this.clipID));
			
		var hasEditChevron = fd.experience.typeName == "More Experience" && fd.experience.canWrite();

		var lines = [];
		
		var s;
		var maxWidth = 0;
		var tspan;
		s = fd.pickedOrCreatedValue("Offering", "User Entered Offering");
		if (s && s.length > 0 && lines.indexOf(s) < 0)
		{
			tspan = detailText.append('tspan')
				.style("font-weight", "bold")
				.text(s)
				.attr("x", this.textDetailLeftMargin)
				.attr("dy", this.detailTextSpacing);
			maxWidth = Math.max(maxWidth, tspan.node().getComputedTextLength());
		}
		
		function checkSpacing(dy)
		{
			if (maxWidth > 0)
				detailText.append('tspan')
						  .text(' ')
						  .attr("x", this.textDetailLeftMargin)
						  .attr("dy", dy);
		}
			
		s = fd.pickedOrCreatedValue("Organization", "User Entered Organization");
		if (s && s.length > 0 && lines.indexOf(s) < 0)
		{
			checkSpacing("4px");
			tspan = detailText.append('tspan')
				.text(s)
				.attr("x", this.textDetailLeftMargin)
				.attr("dy", this.detailTextSpacing);
			maxWidth = Math.max(maxWidth, tspan.node().getComputedTextLength());
		}

		s = fd.pickedOrCreatedValue("Site", "User Entered Site");
		if (s && s.length > 0 && lines.indexOf(s) < 0)
		{
			checkSpacing("2px");
			tspan = detailText.append('tspan')
				.classed('address-line', true)
				.text(s)
				.attr("x", this.textDetailLeftMargin)
				.attr("dy", this.detailTextSpacing);
			maxWidth = Math.max(maxWidth, tspan.node().getComputedTextLength());
		}

		s = getDateRange(fd.experience);
		if (s && s.length > 0)
		{
			checkSpacing("4px");
			tspan = detailText.append('tspan')
				.text(s)
				.attr("x", this.textDetailLeftMargin)
				.attr("dy", this.detailTextSpacing);
			maxWidth = Math.max(maxWidth, tspan.node().getComputedTextLength());
		}
		
		var x = fd.x;
		var y = fd.y;

		var iconAreaWidth = (hasEditChevron ? this.showDetailIconWidth + this.textDetailLeftMargin : 0);
		var maxX = $(this.svg.node()).width() - maxWidth - iconAreaWidth - (this.textDetailLeftMargin * 2);
		if (x > maxX)
			x = maxX;
		var rectWidth = maxWidth + iconAreaWidth + (this.textDetailLeftMargin * 2);
		if (rectWidth < this.flagWidth)
		{
			rectWidth = this.flagWidth;
			maxWidth = rectWidth - iconAreaWidth - (this.textDetailLeftMargin * 2);
		}

		s = getTagList(fd.experience);
		if (s && s.length > 0)
		{
			var text = d3.select(this),
				words = s.split(/\s+/).reverse(),
				word,
				line = [];
			checkSpacing("4px");
			tspan = detailText.append("tspan").attr("x", this.textDetailLeftMargin).classed('tags', true);
			while (word = words.pop()) {
			  line.push(word);
			  tspan.text(line.join(" "));
			  if (tspan.node().getComputedTextLength() > maxWidth) {
				line.pop();
				tspan.text(line.join(" "));
				tspan.attr("dy", this.detailTextSpacing);
				line = [word];
				tspan = detailText.append("tspan").attr("x", this.textDetailLeftMargin).classed('tags', true).text(word);
			  }
			}
			tspan.attr("dy", this.detailTextSpacing);
		}

		var textBox = detailText.node().getBBox();
		var rectHeight = textBox.height + (textBox.y * 2);
		var strokeWidth = parseInt($(this.detailFrontRect.node()).css("stroke-width"));
		var maxY = $(this.svg.node()).height() - rectHeight - strokeWidth;
		if (y > maxY)
			y = maxY;
			
		this.detailGroup.attr("x", x)
				 .attr("y", y)
				 .attr("transform", "translate("+x + "," + y+")")
				 .attr("height", 0);
		this.detailGroup.selectAll('rect')
			.attr("width", rectWidth)
		   .attr("x", textBox.x - this.textDetailLeftMargin)
		   .attr("y", 0);
		this.setColor(this.detailFrontRect.node(), this.detailFrontRect.datum());
		this.detailFrontRect.each(function(d) { _this.setupServicesTriggers(this, d); });
		if (duration > 0)
		{
			this.detailGroup.selectAll('rect').attr("height", 0)
					   .transition()
					   .duration(duration)
					   .attr("height", rectHeight);
		}
		else
		{
			this.detailGroup.selectAll('rect').attr("height", rectHeight);
		}
	   
		/* Set the clip path of the text to grow so the text is revealed in parallel */
		var textClipRect = d3.select("#id_detailClipPath{0}".format(this.clipID)).selectAll('rect')
			.attr('x', textBox.x)
			.attr('y', textBox.y)
			.attr('width', maxWidth); 
		
		var iconClipRect;
		
		if (hasEditChevron)
		{	
			iconClipRect = d3.select("#id_detailIconClipPath{0}".format(this.clipID)).selectAll('rect')
				.attr('x', rectWidth - this.showDetailIconWidth - this.textDetailLeftMargin)
				.attr('y', textBox.y)
				.attr('width', this.showDetailIconWidth);
				
			var detailChevron = this.detailGroup.append('image')
				.attr("width", this.showDetailIconWidth)
				.attr("height", this.showDetailIconWidth)
				.attr("xlink:href", rightChevronPath)
				.attr('clip-path', 'url(#id_detailIconClipPath{0})'.format(this.clipID))

			detailChevron.attr('x', rectWidth - this.showDetailIconWidth - this.textDetailLeftMargin)
				.attr('y', textBox.y + (textBox.height - this.showDetailIconWidth) / 2);
		}
			
		if (duration > 0)
		{
			textClipRect.attr('height', 0)
				.transition()
				.duration(duration)
				.attr('height', textBox.height); 
			detailText				
				.transition()
				.duration(duration)
				.attr("height", textBox.height);

			if (hasEditChevron)
				iconClipRect.attr('height', 0)
					.transition()
					.duration(duration)
					.attr('height', textBox.height);
		}
		else
		{
			textClipRect.attr('height', textBox.height); 
			detailText.attr("height", textBox.height);
			if (hasEditChevron)
				iconClipRect.attr('height', textBox.height);
		}
		
		this.detailFlagData = fd;
		this.flagElement = g;
		
		var experience = this.detailFlagData.experience;
		[experience.getCell("Organization"),
		 experience.getCell("User Entered Organization"),
		 experience.getCell("Site"),
		 experience.getCell("User Entered Site"),
		 experience.getCell("Start"),
		 experience.getCell("End"),
		 experience.getCell("Service"),
		 experience.getCell("User Entered Service")].forEach(function(d)
		 {
			/* d will be null if the experience came from the organization for the 
				User Entered Organization and User Entered Site.
			 */
			if (d)
			{
				$(d).on("dataChanged.cr", null, _this, _this.handleChangeDetailGroup);
				$(d).on("valueAdded.cr", null, _this, _this.handleChangeDetailGroup);
			}
		 });
		[experience.getCell("Service"),
		 experience.getCell("User Entered Service")].forEach(function(d)
		 {
			/* d will be null if the experience came from the organization for the 
				User Entered Organization and User Entered Site.
			 */
			if (d)
			{
				$(d).on("valueDeleted.cr", null, _this, _this.handleChangeDetailGroup);
			}
		 });
		 
	}
	
	Pathtree.prototype.handleChangeDetailGroup = function(eventObject, newValue)
	{
		if (!(eventObject.type == "valueAdded" && newValue && newValue.isEmpty()))
			eventObject.data.refreshDetail();
	}
	
	Pathtree.prototype.clearDetail = function()
	{
		this.detailGroup.selectAll('text').remove();
		this.detailGroup.selectAll('rect').attr('height', 0);
		/* Remove the image here instead of when the other clipPath ends
			so that it is sure to be removed when the done method is called. 
		 */
		this.detailGroup.selectAll('image').remove();
		d3.select("#id_detailClipPath{0}".format(this.clipID)).attr('height', 0);
		d3.select("#id_detailIconClipPath{0}".format(this.clipID)).attr('height', 0);
		
		var _this = this;
		if (this.detailFlagData)
		{
			var experience = this.detailFlagData.experience;
			[experience.getCell("Organization"),
			 experience.getCell("User Entered Organization"),
			 experience.getCell("Site"),
			 experience.getCell("User Entered Site"),
			 experience.getCell("Start"),
			 experience.getCell("End"),
			 experience.getCell("Service"),
			 experience.getCell("User Entered Service")].forEach(function(d)
			 {
				/* d will be null if the experience came from the organization for the 
					User Entered Organization and User Entered Site.
				 */
			 	if (d)
			 	{
					$(d).off("dataChanged.cr", null, _this.handleChangeDetailGroup);
					$(d).off("valueAdded.cr", null, _this.handleChangeDetailGroup);
				}
			 });
			[experience.getCell("Service"),
			 experience.getCell("User Entered Service")].forEach(function(d)
			 {
				/* d will be null if the experience came from the organization for the 
					User Entered Organization and User Entered Site.
				 */
				if (d)
				{
					$(d).off("valueDeleted.cr", null, _this.handleChangeDetailGroup);
				}
			 });
			 
			 this.detailFrontRect.each(this.clearServicesTriggers);
			 
		}
		
		this.detailGroup.datum(null);
		this.detailGroup.selectAll('rect').datum(null);
		this.detailFlagData = null;
		this.flagElement = null;
	}

	Pathtree.prototype.hideDetail = function(done, duration)
	{
		duration = (duration !== undefined ? duration : 250);
		
		var _this = this;
		if (this.flagElement != null)
		{
			if (duration === 0)
			{
				this.clearDetail();
				if (done) done();
			}
			else
			{
				d3.select("#id_detailClipPath{0}".format(this.clipID)).selectAll('rect')
					.transition()
					.attr("height", 0)
					.duration(duration)
					.each("end", function() {
						_this.clearDetail();
						if (done)
							done();
					});
				d3.select("#id_detailIconClipPath{0}".format(this.clipID)).selectAll('rect')
					.transition()
					.duration(duration)
					.attr("height", 0);
				this.detailGroup.selectAll('rect')
					.transition()
					.duration(duration)
					.attr("height", 0);
			}
		}
		else if (done)
			done();
	}
	
	Pathtree.prototype.refreshDetail = function()
	{
		var oldFlagData = this.detailFlagData;
		var oldElement = this.flagElement;
		var _this = this;
		this.hideDetail(
			function() { _this.showDetailGroup(oldElement, oldFlagData, 0); },
			0);
	}
	
	/* setup up each group (this) that displays an experience to delete itself if
		the experience is deleted.
	 */
	Pathtree.prototype.setupDelete = function(fd, node) 
	{
		var _this = this;
		var valueDeleted = function(eventObject)
		{
			d3.select(eventObject.data).remove();
			_this.handleValueDeleted(this);
		};
		
		var dataChanged = function(eventObject)
		{
			var g = d3.select(eventObject.data);
			var t = g.selectAll('text');
			t.text(function(d) { return d.getDescription(); })
			fd.width = t.node().getBBox().width + 
						_this.textLeftMargin + _this.textRightMargin;
			g.selectAll('rect').attr("x", 0)
				.attr("y", 0 )
				.attr("width", function(fd) { return fd.width; } )
				.attr("height", function(fd) { return fd.height; });
			_this.checkOfferingCells(this,
				function()
				{
					var allG = _this.experienceGroup.selectAll('g');
					_this.optimize(allG)
				});
		}
		
		$(fd.experience).one("valueDeleted.cr", null, node, valueDeleted);
		$(fd.experience).on("dataChanged.cr", null, node, dataChanged);
		
		$(node).on("remove", null, fd.experience, function(eventObject)
		{
			$(eventObject.data).off("valueDeleted.cr", null, valueDeleted);
			$(eventObject.data).off("dataChanged.cr", null, dataChanged);
		});
	}
	
	Pathtree.prototype.handleChangeServices = function(eventObject)
	{
		var rect = d3.select(eventObject.data);
		var experience = rect.datum();
		
		Pathtree.prototype.setColor.call(eventObject.data, experience);
	}
	
	Pathtree.prototype.setupServicesTriggers = function(fd)
		{
			var e = fd.experience;
			var serviceCell = e.getCell("Service");
			var userServiceCell = e.getCell("User Entered Service");
			$(serviceCell).on("valueAdded.cr valueDeleted.cr dataChanged.cr", null, this, Pathtree.prototype.handleChangeServices);
			$(userServiceCell).on("valueAdded.cr valueDeleted.cr dataChanged.cr", null, this, Pathtree.prototype.handleChangeServices);
		}
	
	Pathtree.prototype.clearServicesTriggers = function(fd)
		{
			var e = fd.experience;
			var serviceCell = e.getCell("Service");
			var userServiceCell = e.getCell("User Entered Service");
			$(serviceCell).off("valueAdded.cr valueDeleted.cr dataChanged.cr", null, Pathtree.prototype.handleChangeServices);
			$(userServiceCell).off("valueAdded.cr valueDeleted.cr dataChanged.cr", null, Pathtree.prototype.handleChangeServices);
		}
	
	Pathtree.prototype.appendExperiences = function()
	{
		var _this = this;

		$(this.experienceGroup.selectAll('g')[0]).remove();
		var g = this.experienceGroup.selectAll('g')
			.data(this.allExperiences.map(function(e) { return new FlagData(e); }))
			.enter()
			.append('g')
			.each(function(d)
				{
					_this.setupDelete(d, this);
				});
		
		function showDetail(fd, i)
		{
			cr.logRecord('click', 'show detail: ' + fd.getDescription());
			var g = this.parentNode;
			var pathtree = this.pathtree;
			
			pathtree.hideDetail(function() {
					pathtree.showDetailGroup(g, fd); 
				});
		}
		
		/* Set up a clipID that uniquely identifies the clip paths for this Pathtree. */
		this.clipID = Pathtree.prototype.nextClipID;
		Pathtree.prototype.nextClipID += 1;

		g.append('rect')
			.each(function()
				{ this.pathtree = _this; })
			.attr("fill", '#FFFFFF')
			.attr("stroke", '#FFFFFF')
			.attr('x', 0)
			.attr('y', 0);
			
		var handleChangedExperience = function(fd)
		{
			var r = this;
			
			var expChanged = function(eventObject)
			{
				Pathtree.prototype.setColor.call(eventObject.data, fd);
			}
			
			$(fd.experience).on("dataChanged.cr", null, this, expChanged);
			$(this).on("remove", null, fd.experience, function(eventObject)
			{
				$(eventObject.data).off("dataChanged.cr", null, expChanged);
			});
		}

		g.append('rect')
			.each(function()
				{ this.pathtree = _this; })
			.attr("fill-opacity", "0.3")
			.attr("stroke-width", "0")
			.on("click", function() 
				{ 
					d3.event.stopPropagation(); 
				})
			.on("click.cr", showDetail)
			.each(this.setColor)
			.each(handleChangedExperience)
			.each(this.setupServicesTriggers)
			.attr('x', 0)
			.attr('y', 0);
			
		g.append('line')
			.each(this.setColor)
			.each(handleChangedExperience)
			.each(this.setupServicesTriggers)
			.attr('x1', 1)
			.attr('x2', 1)
			.attr('y1', 0)
			.attr('stroke-width', 2);

		/* t is the set of all text nodes. */
		var t = g.append('text')
			.each(function() { this.pathtree = _this; })
			.attr("x", 0)
			.attr("dy", "1.1")
			.attr("transform", "translate({0}, 0)".format(_this.textLeftMargin))
			.text(function(fd) { return fd.getDescription(); })
			.on("click", function() 
				{ 
					d3.event.stopPropagation(); 
				})
			.on("click.cr", showDetail);
	
		/* bbox is used for various height calculations. */
		var bbox;
		if (t.node())
			bbox = t.node().getBBox();
		else
			bbox = {height: 20, y: -18};
			
		this.flagHeight = bbox.height + this.textBottomBorder;
		this.flagY = bbox.y;
		
		var smallBBox;
		t.style('font-size', '10px');
		if (t.node())
			smallBBox = t.node().getBBox();
		else
			smallBBox = {height: 20, y: -18};
		this.smallFlagHeight = smallBBox.height + this.textBottomBorder;
		this.smallFlagY = smallBBox.y;
		t.style('font-size', null);

		this.clearLayout();
		this.checkLayout();
	}
	
	Pathtree.prototype.handleValueDeleted = function(experience)
	{
		var index = this.allExperiences.indexOf(experience);
		if (index >= 0)
			this.allExperiences.splice(index, 1);
		if (this.detailFlagData && experience == this.detailFlagData.experience)
			this.hideDetail(function() { }, 0);
		this.clearLayout();
		this.checkLayout();
	};

	Pathtree.prototype.handleExperienceDateChanged = function(eventObject)
	{
		var _this = eventObject.data;
		_this.setDateRange();
		_this.appendExperiences();
	}
		
	Pathtree.prototype.setupExperienceTriggers = function(experience)
	{
		var _this = this;
		
		var handleDataChanged = function(eventObject)
		{
			var exp = this;
			_this.checkOfferingCells(exp,
				function()
				{
					_this.clearLayout();
					_this.checkLayout();
				});
		}
	
		$(experience).on("dataChanged.cr", null, this, handleDataChanged);
		$(experience.getCell("Start")).on("valueAdded.cr valueDeleted.cr dataChanged.cr", null, this, this.handleExperienceDateChanged);
		$(experience.getCell("End")).on("valueAdded.cr valueDeleted.cr dataChanged.cr", null, this, this.handleExperienceDateChanged);
		
		$(this.sitePanel.node()).on("remove", null, experience, function(eventObject)
		{
			$(eventObject.data).off("dataChanged.cr", null, handleDataChanged);
			$(eventObject.data.getCell("Start")).off("valueAdded.cr valueDeleted.cr dataChanged.cr", null, this.handleExperienceDateChanged);
			$(eventObject.data.getCell("End")).off("valueAdded.cr valueDeleted.cr dataChanged.cr", null, this.handleExperienceDateChanged);
		});
	}
	
	Pathtree.prototype.checkOfferingCells = function(experience, done)
	{
		offering = experience.getValue("Offering");
		if (offering && offering.getValueID() && !offering.isDataLoaded)
		{
			var storedI = crp.getInstance(offering.getValueID());
			if (storedI != null)
			{
				offering.importCells(storedI.cells);
				if (done) done();
			}
			else
			{
				offering.checkCells(undefined, done, asyncFailFunction);
			}
		}
		else
		{
			if (done) done();
		}
	}
	
	Pathtree.prototype.addMoreExperience = function(experience)
	{
		this.checkDateRange(experience);
		
		this.checkOfferingCells(experience);
		
		this.allExperiences.push(experience);
		
		this.setupExperienceTriggers(experience);
		
		this.appendExperiences();
		
		if (this.loadingText)
		{
			this.loadingText.remove();
			this.promptAddText.remove();
			this.loadingText = null;
			this.promptAddText = null;
		}
	}
	
	Pathtree.prototype.handleResize = function()
	{
		var newHeight = this.sitePanel.scrollAreaHeight();
		var pathwayContainer = $(this.pathwayContainer.node());
		$(this.timeContainer.node()).height(newHeight);
		pathwayContainer.height(newHeight);
		pathwayContainer.width(this.sitePanel.scrollAreaWidth() - this.dataLeftMargin);
		
		var svg = $(this.svg.node());
		var isPinnedHeight = (this.isMinHeight && svg.height() > newHeight);
		var isPinnedWidth = (this.isMinHeight && svg.width() > pathwayContainer.width());
		
		if (svg.height() < newHeight ||
			isPinnedHeight ||
			svg.width() != pathwayContainer.width())
		{
			if (svg.height() < newHeight ||
				isPinnedHeight)
			{
				svg.height(newHeight);
				this.scaleDayHeightToSize();
			}
				
			if (svg.width() < pathwayContainer.width() ||
				isPinnedHeight ||
				isPinnedWidth)
				svg.width(pathwayContainer.width());
				
			this.clearLayout();
			this.checkLayout();
		}
	}
	
	Pathtree.prototype.showAllExperiences = function()
	{
		this.setDateRange();
		this.scaleDayHeightToSize();
		
		var _this = this;
		
		var resizeFunction = function()
		{
			_this.handleResize();
		}
	
		var node = this.sitePanel.node();
		this.allExperiences.filter(function(d)
			{
				return d.typeName === "More Experience";
			})
			.forEach(function(d)
			{
				_this.setupExperienceTriggers(d);
			});

		$(this.sitePanel.mainDiv.node()).on("resize.cr", resizeFunction);
	
		this.appendExperiences();
	}
		
	Pathtree.prototype.clear = function()
	{
		$(this).trigger("clear.cr");
		
		d3.select(this.containerDiv).selectAll('div').remove();
		
		this.user = null;
		this.allExperiences = [];
		this.pathwayContainer = null;
		this.timeContainer = null;
		this.svg = null;
		this.svgTime = null;
		this.defs = null;
		this.bg = null;
		this.bgTime = null;
		this.loadingText = null;
		this.promptAddText = null;
		this.experienceGroup = null;
		this.yearGroup = null;
		this.detailGroup = null;
		this.detailFrontRect = null;
		this.detailBackRect = null;
	
		this.detailFlagData = null;
		this.flagElement = null;
		this.flagHeight = 0;
		this.flagWidth = 0;
	
		this.minDate = null;
		this.maxDate = null;
		this.timespan = 0;
		this.isLayoutDirty = true;
		this.isMinHeight = false;
		this.dayHeight = 0;
		this.years = [];
	}
	
	Pathtree.prototype.onExperienceAdded = function(eventObject, newData)
	{
		var _this = this;
		crp.pushCheckCells(newData, ["type"], 
			function() {
				function addExperience() {
					_this.addMoreExperience(newData);
					unblockClick();
				}
				var offering = newData.getValue("Offering");
				if (offering && offering.getValueID() && !offering.isDataLoaded)
					crp.pushCheckCells(offering, undefined, addExperience, syncFailFunction);
				else
					addExperience();
			},
			syncFailFunction);
	}
	
	Pathtree.prototype.createExperience = function()
	{
		var experience = new Experience();
		var _this = this;
		experience.user = this.user;
		$(experience).on("experienceAdded.cr", function(eventObject, newData)
			{
				_this.onExperienceAdded(eventObject, newData);
			});
		return experience;
	}
	
	Pathtree.prototype.startNewExperience = function()
	{
		var experience = this.createExperience();
		
		var panel = new NewExperiencePanel(experience, this.sitePanel.node());
	}
	
	Pathtree.prototype.setUser = function(user, editable)
	{
		if (user.privilege === '_find')
			throw "You do not have permission to see information about {0}".format(user.getDescription());
		if (this.user)
			throw "user has already been set for this pathtree";
			
		var _this = this;
		
		this.user = user;
		editable = (editable !== undefined ? editable : true);
		
		var container = d3.select(this.containerDiv);
		
		this.timeContainer = container.append('div')
			.classed("years", true)
			.style("width", this.dataLeftMargin)
			.style("height", "100%");
		
		this.svgTime = this.timeContainer.append('svg')
			.style("width", this.dataLeftMargin)
			.style("height", "100%");

		this.pathwayContainer = container.append('div')
			.classed("pathway", true)
			.style("width", $(this.containerDiv).width() - this.dataLeftMargin)
			.style("height", "100%");
			
		this.svg = this.pathwayContainer.append('svg')
			.classed("pathway", true)
			.style("width", $(this.containerDiv).width() - this.dataLeftMargin)
			.style("height", "100%");
		
		/* Keep the scrolling of the timeContainer and the pathwayContainer synchronized */
		var timeScroller = function()
			{
				var n = _this.pathwayContainer.node();
				if (this.scrollTop != n.scrollTop)
				{
					$(n).off("scroll", pathwayScroller);
					$(n).one("scroll", pathwayScrollReset);
					n.scrollTop = this.scrollTop;
				}
			}
		var timeScrollReset = function()
			{
				$(this).scroll(timeScroller);
			}
			
		var pathwayScroller = function()
			{
				var n = _this.timeContainer.node();
				if (this.scrollTop != n.scrollTop)
				{
					$(n).off("scroll", timeScroller);
					$(n).one("scroll", timeScrollReset);
					n.scrollTop = this.scrollTop;
				}
			}
		var pathwayScrollReset = function()
			{
				$(this).scroll(pathwayScroller);
			}
			
			
		$(this.timeContainer.node()).scroll(timeScroller);
		$(this.pathwayContainer.node()).scroll(pathwayScroller);

		this.defs = this.svg.append('defs');
	
		/* bg is a rectangle that fills the background with the background color. */
		this.bg = this.svg.append('rect')
			.attr("x", 0).attr("y", 0)
			.style("width", "100%")
			.style("height", "100%")
			.attr("fill", this.pathBackground);
			
		/* bgTime is a rectangle that fills the background of the timeline with the background color. */
		this.bgTime = this.svgTime.append('rect')
			.attr("x", 0).attr("y", 0)
			.style("width", "100%")
			.style("height", "100%")
			.attr("fill", this.pathBackground);
			
		this.loadingMessage = crv.appendLoadingMessage(this.containerDiv)
			.style("position", "absolute")
			.style("left", "0")
			.style("top", "0");
		
		this.experienceGroup = this.svg.append('g')
				.attr("font-family", "San Francisco,Helvetica Neue,Arial,Helvetica,sans-serif")
				.attr("font-size", "1.3rem");
		this.yearGroup = this.svgTime.append('g')
			.attr("fill", "#777");
			
		this.detailGroup = this.svg.append('g')
				.attr("font-family", "San Francisco,Helvetica Neue,Arial,Helvetica,sans-serif")
				.attr("font-size", "1.3rem")
			.style("width", "100%")
			.style("height", "100%")
			.on("click", function(d) 
				{ 
					d3.event.stopPropagation(); 
				})
			.on("click.cr", this.showDetailPanel);
		this.detailBackRect = this.detailGroup.append('rect')
			.attr("fill", this.pathBackground)
			.attr("width", "100%");
		this.detailFrontRect = this.detailGroup.append('rect')
			.attr("fill-opacity", "0.3")
			.attr("stroke-opacity", "0.8")
			.attr("width", "100%");
			
		$(_this.sitePanel.node()).one("revealing.cr", function()
			{
				$(_this.svg.node()).width(_this.sitePanel.scrollAreaWidth() - _this.dataLeftMargin);
			});

		d3.select(this.containerDiv).selectAll('svg')
			.on("click", function() 
			{ 
				d3.event.stopPropagation(); 
			})
			.on("click.cr", function() {
				cr.logRecord('click', 'hide details');
				_this.hideDetail();
			});
		
		var successFunction1 = function(experiences)
		{
			_this.allExperiences = experiences.slice();
			$(experiences).each(function()
			{
				this.setDescription(this.getValue("Offering").getDescription());
			});
		
			crp.getData({path: "#" + _this.user.getValueID() + '::reference(Experience)::reference(Experiences)' + 
								'::reference(Session)::reference(Sessions)::reference(Offering)',
						 done: function(newInstances)
							{
							},
							fail: asyncFailFunction});
			crp.getData({path: "#" + _this.user.getValueID() + '>"More Experiences">"More Experience">Offering',
						 done: function(newInstances)
							{
							},
							fail: asyncFailFunction});			
			crp.getData({path: "(Service,Domain,Stage)", 
						 done: function(newInstances)
							{
							},
							fail: asyncFailFunction});
			crp.getData({path: '"Service Domain"', 
						 done: function(newInstances)
							{
								for (i = 0; i < newInstances.length; ++i)
								{
									if (newInstances[i].getDescription() == "Other")
									{
										color = newInstances[i].getValue("Color");
										if (color && color.text)
											otherColor = color.text;
										break;
									}
								}
							},
						fail: asyncFailFunction});
								
			crp.pushCheckCells(_this.user, undefined, 
				function() {
					/* Check the user in case the panel has been closed. */
					if (_this.user != null)
					{
						var m = _this.user.getValue("More Experiences");
						if (m && m.getValueID())
						{
							m.getCellData("More Experience",
										  successFunction2, 
										  asyncFailFunction);
						}
						else
							successFunction2([]);	/* There are none. */
					}
				},
				function(err)
				{
					asyncHidePanelRight(_this.sitePanel.node());
					asyncFailFunction(err);
				});
		}

		var successFunction2 = function(experiences)
		{
			if (_this.user == null)
				return;	/* The panel has been closed before this asynchronous action occured. */
				
			_this.allExperiences = _this.allExperiences.concat(experiences);
			
			$(experiences).each(function()
			{
				this.calculateDescription();
			});
			
			/* Ensure that all of the offerings have their associated cells. */
			_this.allExperiences.forEach(function(experience)
				{
					_this.checkOfferingCells(experience, null);
				});
		
			_this.showAllExperiences();
			
			crv.stopLoadingMessage(_this.loadingMessage);
			_this.loadingMessage.remove();
			
			if (_this.allExperiences.length == 0 && editable)
			{
				_this.loadingText = _this.svg.append('text')
					.attr("x", 0).attr("y", 0)
					.attr("fill", "#777")
					.text('Ready to record an experience?');
				
				_this.loadingText
					.attr("y", _this.loadingText.node().getBBox().height);
			
				var bbox = _this.loadingText.node().getBBox();
				_this.promptAddText = _this.svg.append('text')
					.attr("fill", "#2C55CC")
					.text(" Record one now.")
					.on("click", function(d) {
						if (prepareClick('click', 'Record one now prompt'))
						{
							try
							{
								showClickFeedback(this);
								_this.startNewExperience();
							}
							catch (err)
							{
								syncFailFunction(err);
							}
						}
						d3.event.preventDefault();
					})
					.attr("cursor", "pointer");
				
				var newBBox = _this.promptAddText.node().getBBox();
				if (bbox.x + bbox.width + _this.textLeftMargin + newBBox.width >
					$(_this.bg.node()).width() - _this.flagsRightMargin)
				{
					_this.promptAddText.attr("x", _this.loadingText.attr("x"))
						.attr("y", parseFloat(_this.loadingText.attr("y")) + bbox.height);
				}
				else
				{
					_this.promptAddText.attr("x", bbox.x + bbox.width + _this.textLeftMargin)
						.attr("y", _this.loadingText.attr("y"));
				}
			}
			
			$(_this).trigger("userSet.cr");
		}
		
		var path = "#" + this.user.getValueID() + '::reference(Experience)';
		crp.getData({path: path, 
				   fields: ["parents", "type"], 
				   done: successFunction1, 
				   fail: asyncFailFunction});
	}

	function Pathtree(sitePanel, containerDiv) {
		this.containerDiv = containerDiv;
		this.sitePanel = sitePanel;
		this.detailFlagData = null;
		this.flagElement = null;
		this.allExperiences = [];
		
		$(this).on("clear.cr", null, null, function() {
			this.clearDetail();
		});
		
	}
	
	return Pathtree;
})();

var PathtreePanel = (function () {
	PathtreePanel.prototype = new SitePanel();
	PathtreePanel.prototype.pathtree = null;
	
	PathtreePanel.prototype.userSettingsBadgeCount = function(user)
	{
		var cell = user.getCell("_access request");
		if (cell && cell.data.length > 0)
			return cell.data.length;
		else
			return "";
	}

	function PathtreePanel(user, previousPanel, canDone) {
		canDone = canDone !== undefined ? canDone : true;
		var _this = this;

		SitePanel.call(this, previousPanel, null, "My Pathtree", "pathway");
		var navContainer = this.appendNavContainer();
		var settingsButton;
		
		if (canDone)
		{
			var backButton = navContainer.appendLeftButton()
				.on("click", handleCloseRightEvent);
			backButton.append("span").text("Done");
			settingsButton = navContainer.appendRightButton();
		}
		else
			settingsButton = navContainer.appendLeftButton();

		settingsButton
			.on("click", 
				function() {
					if (prepareClick('click', "Settings"))
					{
						var panel = new Settings(user, _this.node());
						showPanelUp(panel.node(), unblockClick);
					}
					d3.event.preventDefault();
				})
			.classed("settings", true)
			.style("display", "none")
			.append("img")
			.attr("src", settingsImagePath);
		settingsButton.append("span")
			.classed("badge", true)
			.text(this.userSettingsBadgeCount(user));

		var addExperienceButton = navContainer.appendRightButton()
			.on("click", function(d) {
				if (prepareClick('click', 'add experience'))
				{
					showClickFeedback(this);
					_this.pathtree.startNewExperience();
				}
				d3.event.preventDefault();
			})
			.classed('add-experience-button', true)
			.style("display", "none");
		addExperienceButton.append("span")
			.classed('site-active-text', true)
			.text("+");
		
		navContainer.appendTitle(getUserDescription(user));
		
		var panel2Div = this.appendScrollArea();
		panel2Div.classed('vertical-scrolling', false)
			.classed('no-scrolling', true);

		var bottomNavContainer = this.appendBottomNavContainer();

		var findButton = bottomNavContainer.appendRightButton()
				.on("click",
					function() {
						if (prepareClick('click', 'find experience'))
						{
							showClickFeedback(this);
							var newPanel = new FindExperiencePanel(cr.signedinUser, null, null, _this.node());
							showPanelLeft(newPanel.node(), unblockClick);
						}
						d3.event.preventDefault();
					});
		findButton.append("i").classed("site-active-text fa fa-lg fa-search", true);
		findButton.style("display", "none");
		
		var shareButton = bottomNavContainer.appendLeftButton()
			.classed("share", true)
			.on('click', function()
				{
					if (prepareClick('click', 'delete experience'))
					{
						new ShareOptions(_this.node());
					}
				});
		shareButton.append("img")
			.attr("src", shareImagePath);
		
		/* Add buttons that sit on top of the scroll area. */
		this.expandButton = this.panelDiv.append('button')
			.classed('expand', true)
			.on('click', function(d)
				{
					if (prepareClick('click', 'expand'))
					{
						var _thisButton = d3.select(this);
						_thisButton.classed('pressed', true);
						_this.pathtree.scale(1.3,
							function() { _thisButton.classed('pressed', false); unblockClick(); });
						d3.event.preventDefault();
					}
				});
		this.expandButton
			.append('span').text("+");
		this.contractButton = this.panelDiv.append('button')
			.classed('contract', true)
			.on('click', function(d)
				{
					var _thisButton = d3.select(this);
					if (!_thisButton.classed('disabled'))
					{
						if (prepareClick('click', 'contract'))
						{
							_thisButton.classed('pressed', true);
							_this.pathtree.scale(1/1.3,
								function() { _thisButton.classed('pressed', false); unblockClick(); });
							d3.event.preventDefault();
						}
					}
				});
		this.contractButton
			.append('span').text("");
		
		if (this.pathtree)
			throw "pathtree already assigned to pathtree panel";
			
		this.pathtree = new Pathtree(this, panel2Div.node());
		
		function checkSettingsBadge()
		{
			settingsButton.selectAll("span").text(_this.userSettingsBadgeCount(user));
		}
				
		$(this.node()).on("remove", function()
		{
			_this.pathtree.clear();
			$(user.getCell("_access request")).off("valueDeleted.cr", checkSettingsBadge)
				.off("valueAdded.cr", checkSettingsBadge);
		});
		
		$(this.pathtree).on("userSet.cr", function()
			{
				var moreExperiences = user.getValue("More Experiences");
				var canAddExperience = (moreExperiences.getValueID() === null ? user.canWrite() : moreExperiences.canWrite());
				addExperienceButton.style("display", canAddExperience ? null : "none");
				settingsButton.style("display", user.privilege === "_administer" ? null : "none");
				
				$(user.getCell("_access request")).on("valueDeleted.cr valueAdded.cr", checkSettingsBadge);
				checkSettingsBadge();
				
				findButton.style("display", user.privilege === "_administer" ? null : "none");
				
				this.isMinHeight = true;
				_this.calculateHeight();
			});
	}
	
	return PathtreePanel;
})();

var ShareOptions = (function () {

	function ShareOptions(panelNode)
	{
		var dimmer = d3.select(panelNode).append('div')
			.classed('dimmer', true);
		var panel = d3.select(panelNode).append('panel')
			.classed("confirm", true);
		var div = panel.append('div');
		function onCancel(e)
		{
			if (prepareClick('click', 'Cancel'))
			{
				$(confirmButton.node()).off('blur');
				$(panel.node()).hide("slide", {direction: "down"}, 400, function() {
					panel.remove();
					unblockClick();
				});
				$(dimmer.node()).animate({opacity: 0}, {duration: 400, complete:
					function()
					{
						dimmer.remove();
					}});
			}
			e.preventDefault();
		}
		
		var confirmButton = div.append('button')
			.text("Email Pathway Link")
			.classed("site-active-text", true)
			.on("click", function()
				{
					if (prepareClick('click', "Email Pathway Link"))
					{
						$(panel.node()).hide("slide", {direction: "down"}, 400, function() {
							panel.remove();
							var user = panelNode.sitePanel.pathtree.user;
							if (user.getValueID() == cr.signedinUser.getValueID())
							{
								window.location = 'mailto:?subject=My%20Pathway&body=Here is a link to my pathway: {0}/for/{1}.'
											.format(window.location.origin, user.getDatum("_email"));
							}
							else
							{
								window.location = 'mailto:?subject=Pathway for {0}&body=Here is a link to the pathway for {0}: {1}/for/{2}.'
											.format(getUserDescription(user), window.location.origin, user.getDatum("_email"));
							}
							unblockClick();
						});
						$(dimmer.node()).animate({opacity: 0}, {duration: 400, complete:
							function()
							{
								dimmer.remove();
							}});
					}
				});
				
		$(confirmButton.node()).on('blur', onCancel);
		var cancelButton = div.append('button')
			.text("Cancel")
			.classed("site-active-text", true);
		
		$(cancelButton.node()).click(onCancel);
		
		$(dimmer.node()).animate({opacity: 0.3}, 400);
		$(panel.node()).toggle("slide", {direction: "down", duration: 0});
		$(panel.node()).effect("slide", {direction: "down", duration: 400, complete: 
			function() {
				$(confirmButton.node()).focus();
				unblockClick();
			}});
		$(dimmer.node()).mousedown(onCancel);
		$(panel.node()).mousedown(function(e)
			{
				e.preventDefault();
			});
	}
	
	return ShareOptions;
})();

